Pentru rezolvarea acesteia am creat clasele respective (Problem, Student, Project) unde vom atribui cateva atribute corespunzatoare fiecareia. In primul rand la clasele de tipul Student vom avea doar numele acestora, aferent si celor de Proiect.
Pentru rezolvarea taskurilor am recurs la deducerea legaturilor dintre Student si Project astfel cea mai buna optiune de a pune cele doua in aceeasi oala e de a alege structura de tip Map pentru a vedea Lista aferenta de Proiecte ce le are Studentul.
Pentru aflarea average-ul preferintelor e destul de usor (printr-o filtrare in map si numararea preferintelor acestora ca la urma sa se imparta la numarul studentilor).
Pentru Problem si anume rezolvarea in forma greedy am decurs la tehnica de sortare pentru a alege mereu optiunile cele mai bune pentru fiecare, astfel: am luat mereu in ordinea studentilor care tin mai putine preferinte si fiecare student va lua preferinta cea mai populara (cea mai folosita de ceilalti) iar in cazul in care este deja folosita cu ajutorul atributului boolean isReached vom putea sari peste anumite preferinte deja folosite anterior de alt student.
